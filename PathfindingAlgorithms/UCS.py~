import sets
import sys
import heapq

class PriorityQ(object):
    def __init__(self):
        self.heap = []
    def get(self):
        return heapq.heappop(self.heap)
    def put(self,priority,node,parent):
        heapq.heappush(self.heap,(priority,node,parent))
    def empty(self):
        return (self.heap == []) 

def parse_file():
    if len(sys.argv) < 2:
        print "Error: Not enough inputs"
        sys.exit()
    result_matrix = []
    f = open(sys.argv[1],'r')
    for line in f.readlines():
        if not(line[0] == '#'):
            line = line.split()
            result_matrix.append(map(int,line))
    f.close()
    return result_matrix

def ucs(matrix,root,finish):
    cost = 0
    marked = sets.Set()
    origins = dict()
    visited_nodes = []
    upcoming_nodes = PriorityQ()
    
    origins[0]=None
    upcoming_nodes.put(cost,root,None)

    while(not(upcoming_nodes.empty())):
        cost,node,parent = upcoming_nodes.get()
        if(node not in marked):
            origins[node]=parent
            visited_nodes.append(node)
            if (node == finish):
                return rebuild(node,origins),visited_nodes
            marked.add(node)
            node_children = [ index  for index, element in enumerate(matrix[node]) if element!=0 ]
            for child in node_children:           
                if(child not in marked):
                    upcoming_nodes.put(cost + matrix[node][child],child,node)
    return None

def rebuild(node, origins):
    result = [node]
    current = node
    while(origins[current]!=None):
        current = origins[current]
        result.append(current)
    result.reverse()
    return result
    
def main():
    incidence_matrix = parse_file()
    path,searched = ucs(incidence_matrix,0,len(incidence_matrix)-1)

    output_path = open("path.txt",'w')
    output_searched = open("searched.txt",'w')
    
    for node in path:
        output_path.write(str(node)+'\n')
    for node in searched:
        output_searched.write(str(node)+'\n')

main()
